
fancontroller-v2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007b2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  000007b2  00000846  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000018  0080008c  0080008c  00000872  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000872  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000070  00000000  00000000  000008a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000004a8  00000000  00000000  00000912  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000022c  00000000  00000000  00000dba  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000366  00000000  00000000  00000fe6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001ac  00000000  00000000  0000134c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000037a  00000000  00000000  000014f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000329  00000000  00000000  00001872  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  00001b9b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	50 c3       	rjmp	.+1696   	; 0x6a4 <__vector_1>
   4:	d9 c1       	rjmp	.+946    	; 0x3b8 <__vector_2>
   6:	04 c2       	rjmp	.+1032   	; 0x410 <__vector_3>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
   c:	ca c1       	rjmp	.+916    	; 0x3a2 <__vector_6>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	dd c2       	rjmp	.+1466   	; 0x5cc <__vector_8>
  12:	bc c1       	rjmp	.+888    	; 0x38c <__vector_9>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	94 c1       	rjmp	.+808    	; 0x340 <__vector_11>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>
  1e:	1a c0       	rjmp	.+52     	; 0x54 <__bad_interrupt>
  20:	19 c0       	rjmp	.+50     	; 0x54 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf ed       	ldi	r28, 0xDF	; 223
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_copy_data>:
  2a:	10 e0       	ldi	r17, 0x00	; 0
  2c:	a0 e6       	ldi	r26, 0x60	; 96
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e2 eb       	ldi	r30, 0xB2	; 178
  32:	f7 e0       	ldi	r31, 0x07	; 7
  34:	02 c0       	rjmp	.+4      	; 0x3a <__do_copy_data+0x10>
  36:	05 90       	lpm	r0, Z+
  38:	0d 92       	st	X+, r0
  3a:	ac 38       	cpi	r26, 0x8C	; 140
  3c:	b1 07       	cpc	r27, r17
  3e:	d9 f7       	brne	.-10     	; 0x36 <__do_copy_data+0xc>

00000040 <__do_clear_bss>:
  40:	20 e0       	ldi	r18, 0x00	; 0
  42:	ac e8       	ldi	r26, 0x8C	; 140
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a4 3a       	cpi	r26, 0xA4	; 164
  4c:	b2 07       	cpc	r27, r18
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	a9 d0       	rcall	.+338    	; 0x1a4 <main>
  52:	ad c3       	rjmp	.+1882   	; 0x7ae <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <load_settings_from_eeprom>:
    }
}

void load_settings_from_eeprom(void){
	//load the individual settings from EEPROM
	PWM_LOW_offset		= eeprom_read_byte((uint8_t *) 0); if(PWM_LOW_offset	> 19)	PWM_LOW_offset		= 10;
  56:	80 e0       	ldi	r24, 0x00	; 0
  58:	90 e0       	ldi	r25, 0x00	; 0
  5a:	93 d3       	rcall	.+1830   	; 0x782 <__eerd_byte_tn24a>
  5c:	80 93 89 00 	sts	0x0089, r24
  60:	80 91 89 00 	lds	r24, 0x0089
  64:	84 31       	cpi	r24, 0x14	; 20
  66:	18 f0       	brcs	.+6      	; 0x6e <load_settings_from_eeprom+0x18>
  68:	8a e0       	ldi	r24, 0x0A	; 10
  6a:	80 93 89 00 	sts	0x0089, r24
	PWM_HIGH_offset		= eeprom_read_byte((uint8_t *) 1); if(PWM_HIGH_offset	> 19)	PWM_HIGH_offset		= 10;
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	90 e0       	ldi	r25, 0x00	; 0
  72:	87 d3       	rcall	.+1806   	; 0x782 <__eerd_byte_tn24a>
  74:	80 93 88 00 	sts	0x0088, r24
  78:	80 91 88 00 	lds	r24, 0x0088
  7c:	84 31       	cpi	r24, 0x14	; 20
  7e:	18 f0       	brcs	.+6      	; 0x86 <load_settings_from_eeprom+0x30>
  80:	8a e0       	ldi	r24, 0x0A	; 10
  82:	80 93 88 00 	sts	0x0088, r24
	TACH_LOW_offset		= eeprom_read_byte((uint8_t *) 2); if(TACH_LOW_offset	> 19)	TACH_LOW_offset		= 10;
  86:	82 e0       	ldi	r24, 0x02	; 2
  88:	90 e0       	ldi	r25, 0x00	; 0
  8a:	7b d3       	rcall	.+1782   	; 0x782 <__eerd_byte_tn24a>
  8c:	80 93 8b 00 	sts	0x008B, r24
  90:	80 91 8b 00 	lds	r24, 0x008B
  94:	84 31       	cpi	r24, 0x14	; 20
  96:	18 f0       	brcs	.+6      	; 0x9e <load_settings_from_eeprom+0x48>
  98:	8a e0       	ldi	r24, 0x0A	; 10
  9a:	80 93 8b 00 	sts	0x008B, r24
	TACH_HIGH_offset	= eeprom_read_byte((uint8_t *) 3); if(TACH_HIGH_offset	> 19)	TACH_HIGH_offset	= 10;
  9e:	83 e0       	ldi	r24, 0x03	; 3
  a0:	90 e0       	ldi	r25, 0x00	; 0
  a2:	6f d3       	rcall	.+1758   	; 0x782 <__eerd_byte_tn24a>
  a4:	80 93 8a 00 	sts	0x008A, r24
  a8:	80 91 8a 00 	lds	r24, 0x008A
  ac:	84 31       	cpi	r24, 0x14	; 20
  ae:	18 f0       	brcs	.+6      	; 0xb6 <load_settings_from_eeprom+0x60>
  b0:	8a e0       	ldi	r24, 0x0A	; 10
  b2:	80 93 8a 00 	sts	0x008A, r24
	CURRENT_SETTING		= eeprom_read_byte((uint8_t *) 4); 
  b6:	84 e0       	ldi	r24, 0x04	; 4
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	63 d3       	rcall	.+1734   	; 0x782 <__eerd_byte_tn24a>
  bc:	80 93 8d 00 	sts	0x008D, r24
	
	//increment current setting, check if it isn't exceeding our settings pages and re-store the incremented value to EEPROM
	CURRENT_SETTING++; if(CURRENT_SETTING > MAX_SETTING) CURRENT_SETTING = 0;
  c0:	80 91 8d 00 	lds	r24, 0x008D
  c4:	8f 5f       	subi	r24, 0xFF	; 255
  c6:	80 93 8d 00 	sts	0x008D, r24
  ca:	80 91 8d 00 	lds	r24, 0x008D
  ce:	84 30       	cpi	r24, 0x04	; 4
  d0:	10 f0       	brcs	.+4      	; 0xd6 <load_settings_from_eeprom+0x80>
  d2:	10 92 8d 00 	sts	0x008D, r1
	eeprom_write_byte((uint8_t *) 4, CURRENT_SETTING);
  d6:	60 91 8d 00 	lds	r22, 0x008D
  da:	84 e0       	ldi	r24, 0x04	; 4
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	59 d3       	rcall	.+1714   	; 0x792 <__eewr_byte_tn24a>
	
	//translate the offset settings into actual usable numbers for our calculations
	TACH_LOW_SETTING	= tach_lut[TACH_LOW_offset];
  e0:	e0 91 8b 00 	lds	r30, 0x008B
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	ee 0f       	add	r30, r30
  e8:	ff 1f       	adc	r31, r31
  ea:	e0 5a       	subi	r30, 0xA0	; 160
  ec:	ff 4f       	sbci	r31, 0xFF	; 255
  ee:	80 81       	ld	r24, Z
  f0:	91 81       	ldd	r25, Z+1	; 0x01
  f2:	90 93 9d 00 	sts	0x009D, r25
  f6:	80 93 9c 00 	sts	0x009C, r24
	TACH_HIGH_SETTING	= tach_lut[TACH_HIGH_offset];
  fa:	e0 91 8a 00 	lds	r30, 0x008A
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	ee 0f       	add	r30, r30
 102:	ff 1f       	adc	r31, r31
 104:	e0 5a       	subi	r30, 0xA0	; 160
 106:	ff 4f       	sbci	r31, 0xFF	; 255
 108:	80 81       	ld	r24, Z
 10a:	91 81       	ldd	r25, Z+1	; 0x01
 10c:	90 93 9f 00 	sts	0x009F, r25
 110:	80 93 9e 00 	sts	0x009E, r24
	PWM_LOW_SETTING		= 256 + (PWM_LOW_offset - 10) * 25;
 114:	80 91 89 00 	lds	r24, 0x0089
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	0a 97       	sbiw	r24, 0x0a	; 10
 11c:	69 e1       	ldi	r22, 0x19	; 25
 11e:	70 e0       	ldi	r23, 0x00	; 0
 120:	0b d3       	rcall	.+1558   	; 0x738 <__mulhi3>
 122:	93 95       	inc	r25
 124:	90 93 a1 00 	sts	0x00A1, r25
 128:	80 93 a0 00 	sts	0x00A0, r24
	PWM_HIGH_SETTING	= 512 + (PWM_HIGH_offset - 10) * 25;
 12c:	80 91 88 00 	lds	r24, 0x0088
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	0a 97       	sbiw	r24, 0x0a	; 10
 134:	69 e1       	ldi	r22, 0x19	; 25
 136:	70 e0       	ldi	r23, 0x00	; 0
 138:	ff d2       	rcall	.+1534   	; 0x738 <__mulhi3>
 13a:	9e 5f       	subi	r25, 0xFE	; 254
 13c:	90 93 a3 00 	sts	0x00A3, r25
 140:	80 93 a2 00 	sts	0x00A2, r24
	
	//turn on the relevant LED
	PORTA |= (1 << CURRENT_SETTING);
 144:	2b b3       	in	r18, 0x1b	; 27
 146:	30 91 8d 00 	lds	r19, 0x008D
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	03 2e       	mov	r0, r19
 150:	01 c0       	rjmp	.+2      	; 0x154 <__stack+0x75>
 152:	88 0f       	add	r24, r24
 154:	0a 94       	dec	r0
 156:	ea f7       	brpl	.-6      	; 0x152 <__stack+0x73>
 158:	28 2b       	or	r18, r24
 15a:	2b bb       	out	0x1b, r18	; 27
 15c:	08 95       	ret

0000015e <initialize_hardware>:
}

void initialize_hardware(void){
	//initialize pins/ports
	DDRA	= ADJ_PWMOUT_MIN_PIN | ADJ_PWMOUT_MAX_PIN | ADJ_TACHOUT_MIN_PIN | ADJ_TACHOUT_MAX_PIN |
 15e:	8f e6       	ldi	r24, 0x6F	; 111
 160:	8a bb       	out	0x1a, r24	; 26
			  MISO_TACHMOBO_PIN | MOSI_PWMOUT_PIN;
	DDRB	= 0;	
 162:	17 ba       	out	0x17, r1	; 23
	
	//pull-up on SCK_TACHMOBO
	PORTA  |= MISO_TACHMOBO_PIN;
 164:	dd 9a       	sbi	0x1b, 5	; 27
	PORTB  |= UP_PIN | DOWN_PIN;
 166:	88 b3       	in	r24, 0x18	; 24
 168:	83 60       	ori	r24, 0x03	; 3
 16a:	88 bb       	out	0x18, r24	; 24
	
	//initialize PCINT0
	//PCINT0 triggers on SCK_TACHOUT, measuring the tachometer signal produced by the attached fan
	//it always triggers on the positive edge
	PCMSK0 |= (1 << PCINT4);
 16c:	94 9a       	sbi	0x12, 4	; 18
	
	//initialize PCINT1
	//PCINT1 triggers on any state change of the UP and DOWN buttons
	PCMSK1 |= (1 << PCINT8) | (1 << PCINT9);
 16e:	80 b5       	in	r24, 0x20	; 32
 170:	83 60       	ori	r24, 0x03	; 3
 172:	80 bd       	out	0x20, r24	; 32
	GIMSK  |= (1 << PCIE1);
 174:	8b b7       	in	r24, 0x3b	; 59
 176:	80 62       	ori	r24, 0x20	; 32
 178:	8b bf       	out	0x3b, r24	; 59
	//INT0 triggers on PWM_IN, measuring the PWM signal produced by the motherboard
	
	
	//initialize TCNT0
	//Timer/counter0 is used for the PWM generation, and only that. It just dutifully outputs pwm_period at 32500Hz
	TCCR0B	= TIMER_CLKSEL_DIV1;
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	83 bf       	out	0x33, r24	; 51
	TIMSK0	= TIMER_ENABLE_OVF_INTERRUPT | TIMER_ENABLE_COMPA_INTERRUPT;
 17e:	83 e0       	ldi	r24, 0x03	; 3
 180:	89 bf       	out	0x39, r24	; 57
	OCR0A	= 25;
 182:	99 e1       	ldi	r25, 0x19	; 25
 184:	96 bf       	out	0x36, r25	; 54
	//    a) PWM period     -> pwm_period_m
	//    b) PWM duty cycle -> pwm_duty_m
	//    c) tach period    -> tach_period_m
	// mode 1 is active unless meas=0, where it sweeps the three measurements.
	// default RPM is 7500rpm (=500)
	TCCR1A	= (1 << WGM11);
 186:	92 e0       	ldi	r25, 0x02	; 2
 188:	9f bd       	out	0x2f, r25	; 47
	TCCR1B	= TIMER_CLKSEL_DIV64 | (1 << WGM13) | (1 << WGM12);								//run at clkio/64, use WGM3:0=1110, i.e. fast PWM with TOP=ICR1 and both COMPA and COMPB intact
 18a:	9b e1       	ldi	r25, 0x1B	; 27
 18c:	9e bd       	out	0x2e, r25	; 46
	TIMSK1	= TIMER_ENABLE_OVF_INTERRUPT | TIMER_ENABLE_COMPA_INTERRUPT;
 18e:	8c b9       	out	0x0c, r24	; 12
	OCR1A	= 100;	
 190:	84 e6       	ldi	r24, 0x64	; 100
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	9b bd       	out	0x2b, r25	; 43
 196:	8a bd       	out	0x2a, r24	; 42
	ICR1	= 500;	//default, equivalent to 7500rpm
 198:	84 ef       	ldi	r24, 0xF4	; 244
 19a:	91 e0       	ldi	r25, 0x01	; 1
 19c:	95 bd       	out	0x25, r25	; 37
 19e:	84 bd       	out	0x24, r24	; 36
	
	//all interrupts are armed, now we initialize the PCINT0/INT0 interrupt loop
	//we start at the situation where PCINT0_nINT0=0, i.e. INT0 is active
	
	sei();
 1a0:	78 94       	sei
 1a2:	08 95       	ret

000001a4 <main>:

int main(void)
{
	uint16_t temp_setting = 6;
	
	load_settings_from_eeprom();
 1a4:	58 df       	rcall	.-336    	; 0x56 <load_settings_from_eeprom>
	initialize_hardware();
 1a6:	db df       	rcall	.-74     	; 0x15e <initialize_hardware>
//button variables
volatile uint8_t		button_pressed		= 0;	//boolean telling the main loop whether a button was pressed

int main(void)
{
	uint16_t temp_setting = 6;
 1a8:	c6 e0       	ldi	r28, 0x06	; 6
 1aa:	d0 e0       	ldi	r29, 0x00	; 0
			
			eeprom_write_byte((uint8_t *) CURRENT_SETTING, temp_setting);	//write the updated value to EEPROM
			_delay_ms(5);			//wait 5ms as 'debounce'
			button_pressed = 0;		//and cleared for the next press
			GIFR |= (1 << PCIF1);
			PORTA ^= ALL_LED_MASK;
 1ac:	1f e0       	ldi	r17, 0x0F	; 15
        //buttons are sensed by PCINT1
		//if a button press is sensed (i.e. any change in level), button_pressed
		//will contain information on which button was pressed
		//this is used to modify the offset setting, then translate it into a useful setting,
		//store it in EEPROM and lastly we wait 50ms and rearm the PCINT
		if(button_pressed){
 1ae:	80 91 8c 00 	lds	r24, 0x008C
 1b2:	88 23       	and	r24, r24
 1b4:	e1 f3       	breq	.-8      	; 0x1ae <main+0xa>
			switch(CURRENT_SETTING){
 1b6:	80 91 8d 00 	lds	r24, 0x008D
 1ba:	81 30       	cpi	r24, 0x01	; 1
 1bc:	89 f1       	breq	.+98     	; 0x220 <main+0x7c>
 1be:	38 f0       	brcs	.+14     	; 0x1ce <main+0x2a>
 1c0:	82 30       	cpi	r24, 0x02	; 2
 1c2:	09 f4       	brne	.+2      	; 0x1c6 <main+0x22>
 1c4:	56 c0       	rjmp	.+172    	; 0x272 <main+0xce>
 1c6:	83 30       	cpi	r24, 0x03	; 3
 1c8:	09 f4       	brne	.+2      	; 0x1cc <main+0x28>
 1ca:	7d c0       	rjmp	.+250    	; 0x2c6 <main+0x122>
 1cc:	a5 c0       	rjmp	.+330    	; 0x318 <main+0x174>
				case 0:	//pwm_low
					if(button_pressed == 1 && PWM_LOW_offset < 19)	PWM_LOW_offset++;
 1ce:	80 91 8c 00 	lds	r24, 0x008C
 1d2:	81 30       	cpi	r24, 0x01	; 1
 1d4:	49 f4       	brne	.+18     	; 0x1e8 <main+0x44>
 1d6:	80 91 89 00 	lds	r24, 0x0089
 1da:	83 31       	cpi	r24, 0x13	; 19
 1dc:	28 f4       	brcc	.+10     	; 0x1e8 <main+0x44>
 1de:	80 91 89 00 	lds	r24, 0x0089
 1e2:	8f 5f       	subi	r24, 0xFF	; 255
 1e4:	80 93 89 00 	sts	0x0089, r24
					if(button_pressed == 2 && PWM_LOW_offset > 0)	PWM_LOW_offset--;
 1e8:	80 91 8c 00 	lds	r24, 0x008C
 1ec:	82 30       	cpi	r24, 0x02	; 2
 1ee:	49 f4       	brne	.+18     	; 0x202 <main+0x5e>
 1f0:	80 91 89 00 	lds	r24, 0x0089
 1f4:	88 23       	and	r24, r24
 1f6:	29 f0       	breq	.+10     	; 0x202 <main+0x5e>
 1f8:	80 91 89 00 	lds	r24, 0x0089
 1fc:	81 50       	subi	r24, 0x01	; 1
 1fe:	80 93 89 00 	sts	0x0089, r24
					PWM_LOW_SETTING		= 256 + (PWM_LOW_offset - 10) * 25;
 202:	80 91 89 00 	lds	r24, 0x0089
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	0a 97       	sbiw	r24, 0x0a	; 10
 20a:	69 e1       	ldi	r22, 0x19	; 25
 20c:	70 e0       	ldi	r23, 0x00	; 0
 20e:	94 d2       	rcall	.+1320   	; 0x738 <__mulhi3>
 210:	93 95       	inc	r25
 212:	90 93 a1 00 	sts	0x00A1, r25
 216:	80 93 a0 00 	sts	0x00A0, r24
					temp_setting		= PWM_LOW_offset;
 21a:	c0 91 89 00 	lds	r28, 0x0089
 21e:	7c c0       	rjmp	.+248    	; 0x318 <main+0x174>
					break;
				case 1: //pwm high
					if(button_pressed == 1 && PWM_HIGH_offset < 19) PWM_HIGH_offset++;
 220:	80 91 8c 00 	lds	r24, 0x008C
 224:	81 30       	cpi	r24, 0x01	; 1
 226:	49 f4       	brne	.+18     	; 0x23a <main+0x96>
 228:	80 91 88 00 	lds	r24, 0x0088
 22c:	83 31       	cpi	r24, 0x13	; 19
 22e:	28 f4       	brcc	.+10     	; 0x23a <main+0x96>
 230:	80 91 88 00 	lds	r24, 0x0088
 234:	8f 5f       	subi	r24, 0xFF	; 255
 236:	80 93 88 00 	sts	0x0088, r24
					if(button_pressed == 2 && PWM_HIGH_offset > 0)	PWM_HIGH_offset--;
 23a:	80 91 8c 00 	lds	r24, 0x008C
 23e:	82 30       	cpi	r24, 0x02	; 2
 240:	49 f4       	brne	.+18     	; 0x254 <main+0xb0>
 242:	80 91 88 00 	lds	r24, 0x0088
 246:	88 23       	and	r24, r24
 248:	29 f0       	breq	.+10     	; 0x254 <main+0xb0>
 24a:	80 91 88 00 	lds	r24, 0x0088
 24e:	81 50       	subi	r24, 0x01	; 1
 250:	80 93 88 00 	sts	0x0088, r24
					PWM_HIGH_SETTING	= 512 + (PWM_HIGH_offset - 10) * 25;
 254:	80 91 88 00 	lds	r24, 0x0088
 258:	90 e0       	ldi	r25, 0x00	; 0
 25a:	0a 97       	sbiw	r24, 0x0a	; 10
 25c:	69 e1       	ldi	r22, 0x19	; 25
 25e:	70 e0       	ldi	r23, 0x00	; 0
 260:	6b d2       	rcall	.+1238   	; 0x738 <__mulhi3>
 262:	9e 5f       	subi	r25, 0xFE	; 254
 264:	90 93 a3 00 	sts	0x00A3, r25
 268:	80 93 a2 00 	sts	0x00A2, r24
					temp_setting		= PWM_HIGH_offset;
 26c:	c0 91 88 00 	lds	r28, 0x0088
 270:	53 c0       	rjmp	.+166    	; 0x318 <main+0x174>
					break;
				case 2: //tach_low
					if(button_pressed == 1 && TACH_LOW_offset < 19) TACH_LOW_offset++;
 272:	80 91 8c 00 	lds	r24, 0x008C
 276:	81 30       	cpi	r24, 0x01	; 1
 278:	49 f4       	brne	.+18     	; 0x28c <main+0xe8>
 27a:	80 91 8b 00 	lds	r24, 0x008B
 27e:	83 31       	cpi	r24, 0x13	; 19
 280:	28 f4       	brcc	.+10     	; 0x28c <main+0xe8>
 282:	80 91 8b 00 	lds	r24, 0x008B
 286:	8f 5f       	subi	r24, 0xFF	; 255
 288:	80 93 8b 00 	sts	0x008B, r24
					if(button_pressed == 2 && TACH_LOW_offset > 0)	TACH_LOW_offset--;
 28c:	80 91 8c 00 	lds	r24, 0x008C
 290:	82 30       	cpi	r24, 0x02	; 2
 292:	49 f4       	brne	.+18     	; 0x2a6 <main+0x102>
 294:	80 91 8b 00 	lds	r24, 0x008B
 298:	88 23       	and	r24, r24
 29a:	29 f0       	breq	.+10     	; 0x2a6 <main+0x102>
 29c:	80 91 8b 00 	lds	r24, 0x008B
 2a0:	81 50       	subi	r24, 0x01	; 1
 2a2:	80 93 8b 00 	sts	0x008B, r24
					TACH_LOW_SETTING	= tach_lut[TACH_LOW_offset];
 2a6:	e0 91 8b 00 	lds	r30, 0x008B
 2aa:	f0 e0       	ldi	r31, 0x00	; 0
 2ac:	ee 0f       	add	r30, r30
 2ae:	ff 1f       	adc	r31, r31
 2b0:	e0 5a       	subi	r30, 0xA0	; 160
 2b2:	ff 4f       	sbci	r31, 0xFF	; 255
 2b4:	80 81       	ld	r24, Z
 2b6:	91 81       	ldd	r25, Z+1	; 0x01
 2b8:	90 93 9d 00 	sts	0x009D, r25
 2bc:	80 93 9c 00 	sts	0x009C, r24
					temp_setting		= TACH_LOW_offset;
 2c0:	c0 91 8b 00 	lds	r28, 0x008B
 2c4:	29 c0       	rjmp	.+82     	; 0x318 <main+0x174>
					break;
				case 3: //tach high
					if(button_pressed == 1 && TACH_HIGH_offset < 19) TACH_HIGH_offset++;
 2c6:	80 91 8c 00 	lds	r24, 0x008C
 2ca:	81 30       	cpi	r24, 0x01	; 1
 2cc:	49 f4       	brne	.+18     	; 0x2e0 <main+0x13c>
 2ce:	80 91 8a 00 	lds	r24, 0x008A
 2d2:	83 31       	cpi	r24, 0x13	; 19
 2d4:	28 f4       	brcc	.+10     	; 0x2e0 <main+0x13c>
 2d6:	80 91 8a 00 	lds	r24, 0x008A
 2da:	8f 5f       	subi	r24, 0xFF	; 255
 2dc:	80 93 8a 00 	sts	0x008A, r24
					if(button_pressed == 2 && TACH_HIGH_offset > 0)	TACH_HIGH_offset--;
 2e0:	80 91 8c 00 	lds	r24, 0x008C
 2e4:	82 30       	cpi	r24, 0x02	; 2
 2e6:	49 f4       	brne	.+18     	; 0x2fa <main+0x156>
 2e8:	80 91 8a 00 	lds	r24, 0x008A
 2ec:	88 23       	and	r24, r24
 2ee:	29 f0       	breq	.+10     	; 0x2fa <main+0x156>
 2f0:	80 91 8a 00 	lds	r24, 0x008A
 2f4:	81 50       	subi	r24, 0x01	; 1
 2f6:	80 93 8a 00 	sts	0x008A, r24
					TACH_HIGH_SETTING	= tach_lut[TACH_HIGH_offset];
 2fa:	e0 91 8a 00 	lds	r30, 0x008A
 2fe:	f0 e0       	ldi	r31, 0x00	; 0
 300:	ee 0f       	add	r30, r30
 302:	ff 1f       	adc	r31, r31
 304:	e0 5a       	subi	r30, 0xA0	; 160
 306:	ff 4f       	sbci	r31, 0xFF	; 255
 308:	80 81       	ld	r24, Z
 30a:	91 81       	ldd	r25, Z+1	; 0x01
 30c:	90 93 9f 00 	sts	0x009F, r25
 310:	80 93 9e 00 	sts	0x009E, r24
					temp_setting		= TACH_HIGH_offset;
 314:	c0 91 8a 00 	lds	r28, 0x008A
					break;
			}
			
			eeprom_write_byte((uint8_t *) CURRENT_SETTING, temp_setting);	//write the updated value to EEPROM
 318:	80 91 8d 00 	lds	r24, 0x008D
 31c:	6c 2f       	mov	r22, r28
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	38 d2       	rcall	.+1136   	; 0x792 <__eewr_byte_tn24a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 322:	8f e0       	ldi	r24, 0x0F	; 15
 324:	97 e2       	ldi	r25, 0x27	; 39
 326:	01 97       	sbiw	r24, 0x01	; 1
 328:	f1 f7       	brne	.-4      	; 0x326 <main+0x182>
 32a:	00 c0       	rjmp	.+0      	; 0x32c <main+0x188>
 32c:	00 00       	nop
			_delay_ms(5);			//wait 5ms as 'debounce'
			button_pressed = 0;		//and cleared for the next press
 32e:	10 92 8c 00 	sts	0x008C, r1
			GIFR |= (1 << PCIF1);
 332:	8a b7       	in	r24, 0x3a	; 58
 334:	80 62       	ori	r24, 0x20	; 32
 336:	8a bf       	out	0x3a, r24	; 58
			PORTA ^= ALL_LED_MASK;
 338:	8b b3       	in	r24, 0x1b	; 27
 33a:	81 27       	eor	r24, r17
 33c:	8b bb       	out	0x1b, r24	; 27
 33e:	37 cf       	rjmp	.-402    	; 0x1ae <main+0xa>

00000340 <__vector_11>:
	sei();
}

/* INTERRUPT HANDLERS */
//timer0 overflow interrupt, set MOSI_PWMOUT
ISR(TIM0_OVF_vect){
 340:	1f 92       	push	r1
 342:	0f 92       	push	r0
 344:	0f b6       	in	r0, 0x3f	; 63
 346:	0f 92       	push	r0
 348:	11 24       	eor	r1, r1
 34a:	2f 93       	push	r18
 34c:	8f 93       	push	r24
 34e:	9f 93       	push	r25
	PORTA |= MOSI_PWMOUT_PIN;
 350:	de 9a       	sbi	0x1b, 6	; 27
	meas++;
 352:	80 91 90 00 	lds	r24, 0x0090
 356:	90 91 91 00 	lds	r25, 0x0091
 35a:	01 96       	adiw	r24, 0x01	; 1
	if(meas > MEAS_TIMEOUT){
 35c:	81 31       	cpi	r24, 0x11	; 17
 35e:	27 e2       	ldi	r18, 0x27	; 39
 360:	92 07       	cpc	r25, r18
 362:	28 f4       	brcc	.+10     	; 0x36e <__vector_11+0x2e>

/* INTERRUPT HANDLERS */
//timer0 overflow interrupt, set MOSI_PWMOUT
ISR(TIM0_OVF_vect){
	PORTA |= MOSI_PWMOUT_PIN;
	meas++;
 364:	90 93 91 00 	sts	0x0091, r25
 368:	80 93 90 00 	sts	0x0090, r24
 36c:	07 c0       	rjmp	.+14     	; 0x37c <__vector_11+0x3c>
	if(meas > MEAS_TIMEOUT){
		meas = 0;
 36e:	10 92 91 00 	sts	0x0091, r1
 372:	10 92 90 00 	sts	0x0090, r1
		currently_measuring = 1;
 376:	81 e0       	ldi	r24, 0x01	; 1
 378:	80 93 8f 00 	sts	0x008F, r24
	}
}
 37c:	9f 91       	pop	r25
 37e:	8f 91       	pop	r24
 380:	2f 91       	pop	r18
 382:	0f 90       	pop	r0
 384:	0f be       	out	0x3f, r0	; 63
 386:	0f 90       	pop	r0
 388:	1f 90       	pop	r1
 38a:	18 95       	reti

0000038c <__vector_9>:

//timer0 compare A interrupt, clear MOSI_PWMOUT and LED mask
ISR(TIM0_COMPA_vect){
 38c:	1f 92       	push	r1
 38e:	0f 92       	push	r0
 390:	0f b6       	in	r0, 0x3f	; 63
 392:	0f 92       	push	r0
 394:	11 24       	eor	r1, r1
	PORTA &= ~MOSI_PWMOUT_PIN;
 396:	de 98       	cbi	0x1b, 6	; 27
}
 398:	0f 90       	pop	r0
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	0f 90       	pop	r0
 39e:	1f 90       	pop	r1
 3a0:	18 95       	reti

000003a2 <__vector_6>:
		}
	}
}

//timer1 compare A interrupt, clear MISO_TACHMOBO
ISR(TIM1_COMPA_vect){
 3a2:	1f 92       	push	r1
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	0f 92       	push	r0
 3aa:	11 24       	eor	r1, r1
	PORTA &= ~MISO_TACHMOBO_PIN;
 3ac:	dd 98       	cbi	0x1b, 5	; 27
}
 3ae:	0f 90       	pop	r0
 3b0:	0f be       	out	0x3f, r0	; 63
 3b2:	0f 90       	pop	r0
 3b4:	1f 90       	pop	r1
 3b6:	18 95       	reti

000003b8 <__vector_2>:

//PCINT0 is armed on SCK_TACHOUT
ISR(PCINT0_vect){
 3b8:	1f 92       	push	r1
 3ba:	0f 92       	push	r0
 3bc:	0f b6       	in	r0, 0x3f	; 63
 3be:	0f 92       	push	r0
 3c0:	11 24       	eor	r1, r1
 3c2:	8f 93       	push	r24
 3c4:	9f 93       	push	r25
	if(PINA & SCK_TACHOUT_PIN){	//positive edge
 3c6:	cc 9b       	sbis	0x19, 4	; 25
 3c8:	1c c0       	rjmp	.+56     	; 0x402 <__vector_2+0x4a>
		if(meas_cycle == 1){
 3ca:	80 91 8e 00 	lds	r24, 0x008E
 3ce:	81 30       	cpi	r24, 0x01	; 1
 3d0:	31 f4       	brne	.+12     	; 0x3de <__vector_2+0x26>
			meas_cycle = 2;
 3d2:	82 e0       	ldi	r24, 0x02	; 2
 3d4:	80 93 8e 00 	sts	0x008E, r24
			TCNT1 = 0;	//reset timer
 3d8:	1d bc       	out	0x2d, r1	; 45
 3da:	1c bc       	out	0x2c, r1	; 44
 3dc:	12 c0       	rjmp	.+36     	; 0x402 <__vector_2+0x4a>
		} else if(meas_cycle == 2){
 3de:	82 30       	cpi	r24, 0x02	; 2
 3e0:	81 f4       	brne	.+32     	; 0x402 <__vector_2+0x4a>
			meas_cycle = 3;
 3e2:	83 e0       	ldi	r24, 0x03	; 3
 3e4:	80 93 8e 00 	sts	0x008E, r24
			tach_period_m = TCNT1;
 3e8:	8c b5       	in	r24, 0x2c	; 44
 3ea:	9d b5       	in	r25, 0x2d	; 45
 3ec:	90 93 9b 00 	sts	0x009B, r25
 3f0:	80 93 9a 00 	sts	0x009A, r24
			GIMSK &= ~(1 << PCIE0);		//disarm PCINT0
 3f4:	8b b7       	in	r24, 0x3b	; 59
 3f6:	8f 7e       	andi	r24, 0xEF	; 239
 3f8:	8b bf       	out	0x3b, r24	; 59
			TCNT1 = 18740;
 3fa:	84 e3       	ldi	r24, 0x34	; 52
 3fc:	99 e4       	ldi	r25, 0x49	; 73
 3fe:	9d bd       	out	0x2d, r25	; 45
 400:	8c bd       	out	0x2c, r24	; 44
			//now we just let it overflow and let TIMER1_OVF handle the rest
		}
	}
}
 402:	9f 91       	pop	r25
 404:	8f 91       	pop	r24
 406:	0f 90       	pop	r0
 408:	0f be       	out	0x3f, r0	; 63
 40a:	0f 90       	pop	r0
 40c:	1f 90       	pop	r1
 40e:	18 95       	reti

00000410 <__vector_3>:

//PCINT1 is armed on UP and DOWN
//a button press is going to cause either UP or DOWN to change to LOW, so we test for that to ascertain
//whether we need to increment or decrement the current value
ISR(PCINT1_vect){
 410:	1f 92       	push	r1
 412:	0f 92       	push	r0
 414:	0f b6       	in	r0, 0x3f	; 63
 416:	0f 92       	push	r0
 418:	11 24       	eor	r1, r1
 41a:	8f 93       	push	r24
	if(!button_pressed){	//wait until main() cleared the previous interrupt	
 41c:	80 91 8c 00 	lds	r24, 0x008C
 420:	81 11       	cpse	r24, r1
 422:	0a c0       	rjmp	.+20     	; 0x438 <__vector_3+0x28>
		if(!(PINB & UP_PIN)){
 424:	b1 99       	sbic	0x16, 1	; 22
 426:	03 c0       	rjmp	.+6      	; 0x42e <__vector_3+0x1e>
			button_pressed = 1;	//UP
 428:	81 e0       	ldi	r24, 0x01	; 1
 42a:	80 93 8c 00 	sts	0x008C, r24
		} 
		if(!(PINB & DOWN_PIN)){
 42e:	b0 99       	sbic	0x16, 0	; 22
 430:	03 c0       	rjmp	.+6      	; 0x438 <__vector_3+0x28>
			button_pressed = 2; //DOWN
 432:	82 e0       	ldi	r24, 0x02	; 2
 434:	80 93 8c 00 	sts	0x008C, r24
		}
	}
	
	//the rest is done in main() so as not to choke out other interrupts
}
 438:	8f 91       	pop	r24
 43a:	0f 90       	pop	r0
 43c:	0f be       	out	0x3f, r0	; 63
 43e:	0f 90       	pop	r0
 440:	1f 90       	pop	r1
 442:	18 95       	reti

00000444 <finalize_measurements>:

void finalize_measurements(void){
	uint16_t temp;
	
	//return timer1 to defaults	
	TCCR1B = TIMER_CLKSEL_DIV64 | (1 << WGM13) | (1 << WGM12);	
 444:	8b e1       	ldi	r24, 0x1B	; 27
 446:	8e bd       	out	0x2e, r24	; 46
	meas_cycle = 0;
 448:	10 92 8e 00 	sts	0x008E, r1
	currently_measuring = 0;
 44c:	10 92 8f 00 	sts	0x008F, r1
	
	//TACH_PERIOD
	if(tach_period_m == 65535){	//timeout on tach_period
 450:	80 91 9a 00 	lds	r24, 0x009A
 454:	90 91 9b 00 	lds	r25, 0x009B
 458:	01 96       	adiw	r24, 0x01	; 1
 45a:	49 f4       	brne	.+18     	; 0x46e <finalize_measurements+0x2a>
		//set tach to lowest allowed setting
		tach_period = TACH_LOW_SETTING;
 45c:	80 91 9c 00 	lds	r24, 0x009C
 460:	90 91 9d 00 	lds	r25, 0x009D
 464:	90 93 99 00 	sts	0x0099, r25
 468:	80 93 98 00 	sts	0x0098, r24
 46c:	36 c0       	rjmp	.+108    	; 0x4da <finalize_measurements+0x96>
	} else {
		if(tach_period_m > TACH_LOW_SETTING){		tach_period = TACH_LOW_SETTING;}	//clip on low
 46e:	20 91 9a 00 	lds	r18, 0x009A
 472:	30 91 9b 00 	lds	r19, 0x009B
 476:	80 91 9c 00 	lds	r24, 0x009C
 47a:	90 91 9d 00 	lds	r25, 0x009D
 47e:	82 17       	cp	r24, r18
 480:	93 07       	cpc	r25, r19
 482:	28 f4       	brcc	.+10     	; 0x48e <finalize_measurements+0x4a>
 484:	80 91 9c 00 	lds	r24, 0x009C
 488:	90 91 9d 00 	lds	r25, 0x009D
 48c:	14 c0       	rjmp	.+40     	; 0x4b6 <finalize_measurements+0x72>
		else if(tach_period_m < TACH_HIGH_SETTING){ tach_period = TACH_HIGH_SETTING;}	//clip on high
 48e:	20 91 9a 00 	lds	r18, 0x009A
 492:	30 91 9b 00 	lds	r19, 0x009B
 496:	80 91 9e 00 	lds	r24, 0x009E
 49a:	90 91 9f 00 	lds	r25, 0x009F
 49e:	28 17       	cp	r18, r24
 4a0:	39 07       	cpc	r19, r25
 4a2:	28 f4       	brcc	.+10     	; 0x4ae <finalize_measurements+0x6a>
 4a4:	80 91 9e 00 	lds	r24, 0x009E
 4a8:	90 91 9f 00 	lds	r25, 0x009F
 4ac:	04 c0       	rjmp	.+8      	; 0x4b6 <finalize_measurements+0x72>
		else{										tach_period = tach_period_m;}		//otherwise just transmit exactly what you measure
 4ae:	80 91 9a 00 	lds	r24, 0x009A
 4b2:	90 91 9b 00 	lds	r25, 0x009B
 4b6:	90 93 99 00 	sts	0x0099, r25
 4ba:	80 93 98 00 	sts	0x0098, r24
		ICR1 = tach_period;			//set period
 4be:	80 91 98 00 	lds	r24, 0x0098
 4c2:	90 91 99 00 	lds	r25, 0x0099
 4c6:	95 bd       	out	0x25, r25	; 37
 4c8:	84 bd       	out	0x24, r24	; 36
		OCR1A = tach_period >> 1;	//and make sure it's a 50% square wave
 4ca:	80 91 98 00 	lds	r24, 0x0098
 4ce:	90 91 99 00 	lds	r25, 0x0099
 4d2:	96 95       	lsr	r25
 4d4:	87 95       	ror	r24
 4d6:	9b bd       	out	0x2b, r25	; 43
 4d8:	8a bd       	out	0x2a, r24	; 42
	//PWM
	//this math is a bit more annoying, because we need to scale instead of use absolute values.
	//0-100% PWM input translates into 0[+/-100%]-100[+/-100]% PWM
	
	//first off, deal with the trivial case
	if(pwm_period_m == 65535 || pwm_period_m <= 256 || pwm_duty_m == 65535){	//either no signal present or period is less than 256, our math wont work
 4da:	60 91 92 00 	lds	r22, 0x0092
 4de:	70 91 93 00 	lds	r23, 0x0093
 4e2:	cb 01       	movw	r24, r22
 4e4:	81 50       	subi	r24, 0x01	; 1
 4e6:	91 40       	sbci	r25, 0x01	; 1
 4e8:	8e 3f       	cpi	r24, 0xFE	; 254
 4ea:	9e 4f       	sbci	r25, 0xFE	; 254
 4ec:	40 f4       	brcc	.+16     	; 0x4fe <finalize_measurements+0xba>
 4ee:	80 91 96 00 	lds	r24, 0x0096
 4f2:	90 91 97 00 	lds	r25, 0x0097
 4f6:	8f 3f       	cpi	r24, 0xFF	; 255
 4f8:	2f ef       	ldi	r18, 0xFF	; 255
 4fa:	92 07       	cpc	r25, r18
 4fc:	69 f5       	brne	.+90     	; 0x558 <finalize_measurements+0x114>
		pwm_duty = PWM_LOW_SETTING;
 4fe:	80 91 a0 00 	lds	r24, 0x00A0
 502:	90 91 a1 00 	lds	r25, 0x00A1
		if(pwm_duty < 256)	pwm_duty = 1; 
 506:	8f 3f       	cpi	r24, 0xFF	; 255
 508:	91 05       	cpc	r25, r1
 50a:	09 f0       	breq	.+2      	; 0x50e <finalize_measurements+0xca>
 50c:	10 f4       	brcc	.+4      	; 0x512 <finalize_measurements+0xce>
 50e:	81 e0       	ldi	r24, 0x01	; 1
 510:	90 e0       	ldi	r25, 0x00	; 0
 512:	90 93 95 00 	sts	0x0095, r25
 516:	80 93 94 00 	sts	0x0094, r24
		if(pwm_duty > 511)	pwm_duty = 255;
 51a:	80 91 94 00 	lds	r24, 0x0094
 51e:	90 91 95 00 	lds	r25, 0x0095
 522:	81 15       	cp	r24, r1
 524:	92 40       	sbci	r25, 0x02	; 2
 526:	30 f0       	brcs	.+12     	; 0x534 <finalize_measurements+0xf0>
 528:	8f ef       	ldi	r24, 0xFF	; 255
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	90 93 95 00 	sts	0x0095, r25
 530:	80 93 94 00 	sts	0x0094, r24
		if(pwm_duty > 255)	pwm_duty -= 255;
 534:	80 91 94 00 	lds	r24, 0x0094
 538:	90 91 95 00 	lds	r25, 0x0095
 53c:	8f 3f       	cpi	r24, 0xFF	; 255
 53e:	91 05       	cpc	r25, r1
 540:	39 f0       	breq	.+14     	; 0x550 <finalize_measurements+0x10c>
 542:	30 f0       	brcs	.+12     	; 0x550 <finalize_measurements+0x10c>
 544:	8f 5f       	subi	r24, 0xFF	; 255
 546:	91 09       	sbc	r25, r1
 548:	90 93 95 00 	sts	0x0095, r25
 54c:	80 93 94 00 	sts	0x0094, r24
		OCR0A = pwm_duty;
 550:	80 91 94 00 	lds	r24, 0x0094
 554:	86 bf       	out	0x36, r24	; 54
 556:	08 95       	ret
	} else {																	//valid signal
		//First, we need to calculate the % PWM normalized to 0-256. Ideally we just scale by a float, but this is too expensive. 
		//best alternative is to integer multiply and divide, i.e. we want to do: pwm_duty = 256 x pwm_duty_m / pwm_period_m
		//say the period is 320 and duty cycle is 10%, we get 64 x 32 / 320 = 25. Bang on.
		//unfortunately, this clashes with the max. value we get in the next calculation, so we have to scale everything down by 2 bits
		pwm_period_m >>= 2;
 558:	76 95       	lsr	r23
 55a:	67 95       	ror	r22
 55c:	76 95       	lsr	r23
 55e:	67 95       	ror	r22
 560:	70 93 93 00 	sts	0x0093, r23
 564:	60 93 92 00 	sts	0x0092, r22
		pwm_duty = (pwm_duty_m << 6) / pwm_period_m;
 568:	56 e0       	ldi	r21, 0x06	; 6
 56a:	88 0f       	add	r24, r24
 56c:	99 1f       	adc	r25, r25
 56e:	5a 95       	dec	r21
 570:	e1 f7       	brne	.-8      	; 0x56a <finalize_measurements+0x126>
 572:	f3 d0       	rcall	.+486    	; 0x75a <__udivmodhi4>
 574:	fb 01       	movw	r30, r22
 576:	70 93 95 00 	sts	0x0095, r23
 57a:	60 93 94 00 	sts	0x0094, r22
		
		//now we know the pwm duty cycle input, we need to transform this to output. 
		//the output is ((64 - pwm_duty) x pwm_low + pwm_duty x pwm_high) / 64
		//so for instance if it is 25% (pwm_duty = 64) and pwm_low=0, pwm_high = 256, we get [(64 - 64) x 0 + 16 x 256]/64 = 64
		temp = (64 - pwm_duty) * PWM_LOW_SETTING;	//add contribution of PWM_LOW_SETTING
 57e:	60 91 a0 00 	lds	r22, 0x00A0
 582:	70 91 a1 00 	lds	r23, 0x00A1
 586:	80 e4       	ldi	r24, 0x40	; 64
 588:	90 e0       	ldi	r25, 0x00	; 0
 58a:	8e 1b       	sub	r24, r30
 58c:	9f 0b       	sbc	r25, r31
 58e:	d4 d0       	rcall	.+424    	; 0x738 <__mulhi3>
 590:	9c 01       	movw	r18, r24
		temp += pwm_duty * PWM_HIGH_SETTING;		//add contribution of PWM_HIGH_SETTING
 592:	60 91 a2 00 	lds	r22, 0x00A2
 596:	70 91 a3 00 	lds	r23, 0x00A3
 59a:	cf 01       	movw	r24, r30
 59c:	cd d0       	rcall	.+410    	; 0x738 <__mulhi3>
 59e:	28 0f       	add	r18, r24
 5a0:	39 1f       	adc	r19, r25
		temp >>= 6;									//divide by 64
 5a2:	66 e0       	ldi	r22, 0x06	; 6
 5a4:	36 95       	lsr	r19
 5a6:	27 95       	ror	r18
 5a8:	6a 95       	dec	r22
 5aa:	e1 f7       	brne	.-8      	; 0x5a4 <finalize_measurements+0x160>
		
		if(temp < 257) temp = 257;					//check if its 'negative' (less than 256)
 5ac:	21 30       	cpi	r18, 0x01	; 1
 5ae:	81 e0       	ldi	r24, 0x01	; 1
 5b0:	38 07       	cpc	r19, r24
 5b2:	38 f0       	brcs	.+14     	; 0x5c2 <finalize_measurements+0x17e>
		if(temp > 511) temp = 511;					//check if its 'more than 100%' (more than 511)
 5b4:	21 15       	cp	r18, r1
 5b6:	82 e0       	ldi	r24, 0x02	; 2
 5b8:	38 07       	cpc	r19, r24
 5ba:	28 f0       	brcs	.+10     	; 0x5c6 <finalize_measurements+0x182>
 5bc:	2f ef       	ldi	r18, 0xFF	; 255
 5be:	31 e0       	ldi	r19, 0x01	; 1
 5c0:	02 c0       	rjmp	.+4      	; 0x5c6 <finalize_measurements+0x182>
		//so for instance if it is 25% (pwm_duty = 64) and pwm_low=0, pwm_high = 256, we get [(64 - 64) x 0 + 16 x 256]/64 = 64
		temp = (64 - pwm_duty) * PWM_LOW_SETTING;	//add contribution of PWM_LOW_SETTING
		temp += pwm_duty * PWM_HIGH_SETTING;		//add contribution of PWM_HIGH_SETTING
		temp >>= 6;									//divide by 64
		
		if(temp < 257) temp = 257;					//check if its 'negative' (less than 256)
 5c2:	21 e0       	ldi	r18, 0x01	; 1
 5c4:	31 e0       	ldi	r19, 0x01	; 1
		if(temp > 511) temp = 511;					//check if its 'more than 100%' (more than 511)
		
		temp -= 256;								//shift range to 0-256
 5c6:	3a 95       	dec	r19
		
		OCR0A = (uint8_t) temp;						//and throw it into the mix
 5c8:	26 bf       	out	0x36, r18	; 54
 5ca:	08 95       	ret

000005cc <__vector_8>:
ISR(TIM0_COMPA_vect){
	PORTA &= ~MOSI_PWMOUT_PIN;
}

//timer1 overflow interrupt, set MISO_TACHMOBO
ISR(TIM1_OVF_vect){
 5cc:	1f 92       	push	r1
 5ce:	0f 92       	push	r0
 5d0:	0f b6       	in	r0, 0x3f	; 63
 5d2:	0f 92       	push	r0
 5d4:	11 24       	eor	r1, r1
 5d6:	2f 93       	push	r18
 5d8:	3f 93       	push	r19
 5da:	4f 93       	push	r20
 5dc:	5f 93       	push	r21
 5de:	6f 93       	push	r22
 5e0:	7f 93       	push	r23
 5e2:	8f 93       	push	r24
 5e4:	9f 93       	push	r25
 5e6:	af 93       	push	r26
 5e8:	bf 93       	push	r27
 5ea:	ef 93       	push	r30
 5ec:	ff 93       	push	r31
	if(!currently_measuring){
 5ee:	80 91 8f 00 	lds	r24, 0x008F
 5f2:	81 11       	cpse	r24, r1
 5f4:	02 c0       	rjmp	.+4      	; 0x5fa <__vector_8+0x2e>
		PORTA |= MISO_TACHMOBO_PIN;
 5f6:	dd 9a       	sbi	0x1b, 5	; 27
 5f8:	44 c0       	rjmp	.+136    	; 0x682 <__vector_8+0xb6>
	} else {
		switch(meas_cycle){
 5fa:	80 91 8e 00 	lds	r24, 0x008E
 5fe:	83 30       	cpi	r24, 0x03	; 3
 600:	68 f4       	brcc	.+26     	; 0x61c <__vector_8+0x50>
 602:	81 30       	cpi	r24, 0x01	; 1
 604:	08 f5       	brcc	.+66     	; 0x648 <__vector_8+0x7c>
			case 0:	//just getting started
				PORTA &= ~(MISO_TACHMOBO_PIN);
 606:	dd 98       	cbi	0x1b, 5	; 27
				meas_cycle = 1;
 608:	81 e0       	ldi	r24, 0x01	; 1
 60a:	80 93 8e 00 	sts	0x008E, r24
				ICR1 = 18750;												//the slowest fan speed we want to measure is 200rpm, which is 18750 cycles
 60e:	8e e3       	ldi	r24, 0x3E	; 62
 610:	99 e4       	ldi	r25, 0x49	; 73
 612:	95 bd       	out	0x25, r25	; 37
 614:	84 bd       	out	0x24, r24	; 36
				GIMSK |= (1 << PCIE0);										//arm PCINT0				
 616:	8b b7       	in	r24, 0x3b	; 59
 618:	80 61       	ori	r24, 0x10	; 16
 61a:	32 c0       	rjmp	.+100    	; 0x680 <__vector_8+0xb4>
//timer1 overflow interrupt, set MISO_TACHMOBO
ISR(TIM1_OVF_vect){
	if(!currently_measuring){
		PORTA |= MISO_TACHMOBO_PIN;
	} else {
		switch(meas_cycle){
 61c:	83 30       	cpi	r24, 0x03	; 3
 61e:	01 f1       	breq	.+64     	; 0x660 <__vector_8+0x94>
 620:	87 30       	cpi	r24, 0x07	; 7
 622:	78 f5       	brcc	.+94     	; 0x682 <__vector_8+0xb6>
			case 4: 
			case 5:
			case 6:
				//ending up at 4, 5 or 6 means we've timed out of either period or duty cycle measurement.
				//this can mean three things: We're measuring no flanks because PWM is 100%, PWM is 0% or no PWM is present
				GIMSK &= ~(1 << INT0);										//disarm INT0
 624:	8b b7       	in	r24, 0x3b	; 59
 626:	8f 7b       	andi	r24, 0xBF	; 191
 628:	8b bf       	out	0x3b, r24	; 59
				pwm_period_m = 65535;										//make sure finalize_measurements understands we've timed out
 62a:	8f ef       	ldi	r24, 0xFF	; 255
 62c:	9f ef       	ldi	r25, 0xFF	; 255
 62e:	90 93 93 00 	sts	0x0093, r25
 632:	80 93 92 00 	sts	0x0092, r24
				pwm_duty_m = 65535;											//same
 636:	90 93 97 00 	sts	0x0097, r25
 63a:	80 93 96 00 	sts	0x0096, r24
				meas_cycle = 7;
 63e:	87 e0       	ldi	r24, 0x07	; 7
 640:	80 93 8e 00 	sts	0x008E, r24
				finalize_measurements();
 644:	ff de       	rcall	.-514    	; 0x444 <finalize_measurements>
				break;
 646:	1d c0       	rjmp	.+58     	; 0x682 <__vector_8+0xb6>
				break;
			case 1:
			case 2:	//we should not get here unless the measurement cycle timed out.
				//we assume that no fan is present, so we default to the low tach setting
				//PORTA |= MISO_TACHMOBO_PIN;
				meas_cycle = 3;												//skip to PWM measurement (note there is no break)
 648:	83 e0       	ldi	r24, 0x03	; 3
 64a:	80 93 8e 00 	sts	0x008E, r24
				GIMSK &= ~(1 << PCIE0);										//disarm PCINT0
 64e:	8b b7       	in	r24, 0x3b	; 59
 650:	8f 7e       	andi	r24, 0xEF	; 239
 652:	8b bf       	out	0x3b, r24	; 59
				tach_period_m = 65535;										//make sure finalize_measurements understands we've timed out					
 654:	8f ef       	ldi	r24, 0xFF	; 255
 656:	9f ef       	ldi	r25, 0xFF	; 255
 658:	90 93 9b 00 	sts	0x009B, r25
 65c:	80 93 9a 00 	sts	0x009A, r24
			case 3: //starting the PWM measurement, we need to run the clock much faster to capture it.
				meas_cycle = 4;												//make sure we never end up here again
 660:	84 e0       	ldi	r24, 0x04	; 4
 662:	80 93 8e 00 	sts	0x008E, r24
				TCCR1B = TIMER_CLKSEL_DIV1 | (1 << WGM13) | (1 << WGM12);	//run at clkio/1
 666:	89 e1       	ldi	r24, 0x19	; 25
 668:	8e bd       	out	0x2e, r24	; 46
				ICR1 = 375;													//the maximum possible time a PWM cycle can last is about 375 cpu cycles (20% buffer on top of 25kHz), so lets double that and call it quits
 66a:	87 e7       	ldi	r24, 0x77	; 119
 66c:	91 e0       	ldi	r25, 0x01	; 1
 66e:	95 bd       	out	0x25, r25	; 37
 670:	84 bd       	out	0x24, r24	; 36
				TCNT1 = 0;													//reset the clock
 672:	1d bc       	out	0x2d, r1	; 45
 674:	1c bc       	out	0x2c, r1	; 44
				MCUCR |= (1 << ISC00) | (1 << ISC01);						//arm INT0 on positive edge
 676:	85 b7       	in	r24, 0x35	; 53
 678:	83 60       	ori	r24, 0x03	; 3
 67a:	85 bf       	out	0x35, r24	; 53
				GIMSK |= (1 << INT0);
 67c:	8b b7       	in	r24, 0x3b	; 59
 67e:	80 64       	ori	r24, 0x40	; 64
 680:	8b bf       	out	0x3b, r24	; 59
			case 7:
				//we're done. We accidentally triggered this overflow, because finalize_measurements is supposed to take care of everything.
				break;
		}
	}
}
 682:	ff 91       	pop	r31
 684:	ef 91       	pop	r30
 686:	bf 91       	pop	r27
 688:	af 91       	pop	r26
 68a:	9f 91       	pop	r25
 68c:	8f 91       	pop	r24
 68e:	7f 91       	pop	r23
 690:	6f 91       	pop	r22
 692:	5f 91       	pop	r21
 694:	4f 91       	pop	r20
 696:	3f 91       	pop	r19
 698:	2f 91       	pop	r18
 69a:	0f 90       	pop	r0
 69c:	0f be       	out	0x3f, r0	; 63
 69e:	0f 90       	pop	r0
 6a0:	1f 90       	pop	r1
 6a2:	18 95       	reti

000006a4 <__vector_1>:
	}
	
	//the rest is done in main() so as not to choke out other interrupts
}

ISR(EXT_INT0_vect){
 6a4:	1f 92       	push	r1
 6a6:	0f 92       	push	r0
 6a8:	0f b6       	in	r0, 0x3f	; 63
 6aa:	0f 92       	push	r0
 6ac:	11 24       	eor	r1, r1
 6ae:	2f 93       	push	r18
 6b0:	3f 93       	push	r19
 6b2:	4f 93       	push	r20
 6b4:	5f 93       	push	r21
 6b6:	6f 93       	push	r22
 6b8:	7f 93       	push	r23
 6ba:	8f 93       	push	r24
 6bc:	9f 93       	push	r25
 6be:	af 93       	push	r26
 6c0:	bf 93       	push	r27
 6c2:	ef 93       	push	r30
 6c4:	ff 93       	push	r31
	switch(meas_cycle){
 6c6:	80 91 8e 00 	lds	r24, 0x008E
 6ca:	85 30       	cpi	r24, 0x05	; 5
 6cc:	41 f0       	breq	.+16     	; 0x6de <__vector_1+0x3a>
 6ce:	86 30       	cpi	r24, 0x06	; 6
 6d0:	a9 f0       	breq	.+42     	; 0x6fc <__vector_1+0x58>
 6d2:	84 30       	cpi	r24, 0x04	; 4
 6d4:	01 f5       	brne	.+64     	; 0x716 <__vector_1+0x72>
		case 4:	//start: we're synced with a positive flank
			TCNT1 = 0;
 6d6:	1d bc       	out	0x2d, r1	; 45
 6d8:	1c bc       	out	0x2c, r1	; 44
			meas_cycle = 5;
 6da:	85 e0       	ldi	r24, 0x05	; 5
 6dc:	0c c0       	rjmp	.+24     	; 0x6f6 <__vector_1+0x52>
			break;
		case 5: //we captured a second positive flank
			pwm_period_m = TCNT1;
 6de:	8c b5       	in	r24, 0x2c	; 44
 6e0:	9d b5       	in	r25, 0x2d	; 45
 6e2:	90 93 93 00 	sts	0x0093, r25
 6e6:	80 93 92 00 	sts	0x0092, r24
			TCNT1 = 0;
 6ea:	1d bc       	out	0x2d, r1	; 45
 6ec:	1c bc       	out	0x2c, r1	; 44
			MCUCR &= ~(1 << ISC00);	//arm INT0 to negative edge
 6ee:	85 b7       	in	r24, 0x35	; 53
 6f0:	8e 7f       	andi	r24, 0xFE	; 254
 6f2:	85 bf       	out	0x35, r24	; 53
			meas_cycle = 6;
 6f4:	86 e0       	ldi	r24, 0x06	; 6
 6f6:	80 93 8e 00 	sts	0x008E, r24
			break;
 6fa:	0d c0       	rjmp	.+26     	; 0x716 <__vector_1+0x72>
		case 6: //and we captured a negative flank after a positive one
			pwm_duty_m = TCNT1;
 6fc:	8c b5       	in	r24, 0x2c	; 44
 6fe:	9d b5       	in	r25, 0x2d	; 45
 700:	90 93 97 00 	sts	0x0097, r25
 704:	80 93 96 00 	sts	0x0096, r24
			GIMSK &= ~(1 << INT0);	//disarm INT0
 708:	8b b7       	in	r24, 0x3b	; 59
 70a:	8f 7b       	andi	r24, 0xBF	; 191
 70c:	8b bf       	out	0x3b, r24	; 59
			meas_cycle = 7;
 70e:	87 e0       	ldi	r24, 0x07	; 7
 710:	80 93 8e 00 	sts	0x008E, r24
			finalize_measurements();
 714:	97 de       	rcall	.-722    	; 0x444 <finalize_measurements>
			break;
	}			
}
 716:	ff 91       	pop	r31
 718:	ef 91       	pop	r30
 71a:	bf 91       	pop	r27
 71c:	af 91       	pop	r26
 71e:	9f 91       	pop	r25
 720:	8f 91       	pop	r24
 722:	7f 91       	pop	r23
 724:	6f 91       	pop	r22
 726:	5f 91       	pop	r21
 728:	4f 91       	pop	r20
 72a:	3f 91       	pop	r19
 72c:	2f 91       	pop	r18
 72e:	0f 90       	pop	r0
 730:	0f be       	out	0x3f, r0	; 63
 732:	0f 90       	pop	r0
 734:	1f 90       	pop	r1
 736:	18 95       	reti

00000738 <__mulhi3>:
 738:	00 24       	eor	r0, r0
 73a:	55 27       	eor	r21, r21
 73c:	04 c0       	rjmp	.+8      	; 0x746 <__mulhi3+0xe>
 73e:	08 0e       	add	r0, r24
 740:	59 1f       	adc	r21, r25
 742:	88 0f       	add	r24, r24
 744:	99 1f       	adc	r25, r25
 746:	00 97       	sbiw	r24, 0x00	; 0
 748:	29 f0       	breq	.+10     	; 0x754 <__mulhi3+0x1c>
 74a:	76 95       	lsr	r23
 74c:	67 95       	ror	r22
 74e:	b8 f3       	brcs	.-18     	; 0x73e <__mulhi3+0x6>
 750:	71 05       	cpc	r23, r1
 752:	b9 f7       	brne	.-18     	; 0x742 <__mulhi3+0xa>
 754:	80 2d       	mov	r24, r0
 756:	95 2f       	mov	r25, r21
 758:	08 95       	ret

0000075a <__udivmodhi4>:
 75a:	aa 1b       	sub	r26, r26
 75c:	bb 1b       	sub	r27, r27
 75e:	51 e1       	ldi	r21, 0x11	; 17
 760:	07 c0       	rjmp	.+14     	; 0x770 <__udivmodhi4_ep>

00000762 <__udivmodhi4_loop>:
 762:	aa 1f       	adc	r26, r26
 764:	bb 1f       	adc	r27, r27
 766:	a6 17       	cp	r26, r22
 768:	b7 07       	cpc	r27, r23
 76a:	10 f0       	brcs	.+4      	; 0x770 <__udivmodhi4_ep>
 76c:	a6 1b       	sub	r26, r22
 76e:	b7 0b       	sbc	r27, r23

00000770 <__udivmodhi4_ep>:
 770:	88 1f       	adc	r24, r24
 772:	99 1f       	adc	r25, r25
 774:	5a 95       	dec	r21
 776:	a9 f7       	brne	.-22     	; 0x762 <__udivmodhi4_loop>
 778:	80 95       	com	r24
 77a:	90 95       	com	r25
 77c:	bc 01       	movw	r22, r24
 77e:	cd 01       	movw	r24, r26
 780:	08 95       	ret

00000782 <__eerd_byte_tn24a>:
 782:	e1 99       	sbic	0x1c, 1	; 28
 784:	fe cf       	rjmp	.-4      	; 0x782 <__eerd_byte_tn24a>
 786:	1f ba       	out	0x1f, r1	; 31
 788:	8e bb       	out	0x1e, r24	; 30
 78a:	e0 9a       	sbi	0x1c, 0	; 28
 78c:	99 27       	eor	r25, r25
 78e:	8d b3       	in	r24, 0x1d	; 29
 790:	08 95       	ret

00000792 <__eewr_byte_tn24a>:
 792:	26 2f       	mov	r18, r22

00000794 <__eewr_r18_tn24a>:
 794:	e1 99       	sbic	0x1c, 1	; 28
 796:	fe cf       	rjmp	.-4      	; 0x794 <__eewr_r18_tn24a>
 798:	1c ba       	out	0x1c, r1	; 28
 79a:	1f ba       	out	0x1f, r1	; 31
 79c:	8e bb       	out	0x1e, r24	; 30
 79e:	2d bb       	out	0x1d, r18	; 29
 7a0:	0f b6       	in	r0, 0x3f	; 63
 7a2:	f8 94       	cli
 7a4:	e2 9a       	sbi	0x1c, 2	; 28
 7a6:	e1 9a       	sbi	0x1c, 1	; 28
 7a8:	0f be       	out	0x3f, r0	; 63
 7aa:	01 96       	adiw	r24, 0x01	; 1
 7ac:	08 95       	ret

000007ae <_exit>:
 7ae:	f8 94       	cli

000007b0 <__stop_program>:
 7b0:	ff cf       	rjmp	.-2      	; 0x7b0 <__stop_program>
